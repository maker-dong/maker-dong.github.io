# Scala进阶用法

# **函数式编程**

## **遍历foreach**

- 接收一个函数作为参数
- 把每个函数的传入参数传递给函数执行
- 不收集函数的返回值
- foreach本身也没有返回值

## **映射map**

- 接收一个函数作为参数
- 函数有返回值
- map方法收集每一个返回值
- 把每个函数的传入参数传递给函数执行
- 每一次函数的执行结果都被收集
- 最终所有结果封装成一个集合，作为map方法的返回值

## **映射扁平化flatmap**

- 先执行map后执行flatten
- 因为flatten方法不接收参数，所有flatmap参数就是给map用的

## **过滤filter**

- 接收一个函数，该函数返回boolean，对每个元素调用函数
- 如果结果为true则保存下了，如果为false则不保存
- 最终返回一个集合

## **排序**

### **默认排序sorted**

### **指定字段排序sortBy**

```scala
def sortBy[B](f: (A) ⇒ B): List[A]              
```

### **自定义排序sortWith**

```scala
def sortWith(lt: (A, A) ⇒ Boolean): List[A]              
```

## **分组groupBy**

接受一个函数，函数接受一个参数，返回一个对象
`groupBy` 对函数返回的对象进行分组，以返回的对象做为key，满足这个对象的所有元素封装到一个list中作为value

## **聚合操作**

**聚合reduce**

- 聚合接收一个函数，函数接收两个参数
- 第一个参数是上一次执行的结果
- 第二个参数是本次要执行的元素

`reduceLeft == reduce`	表明从左到右

`reduceRight == reduce`	表名从右到左

参数1永远是上一次的结果，第一次是0

参数2由从左到右与从右到做决定

## **折叠fold**

- fold包括foldLeft foldRight
- 在执行逻辑上与reduce相同
- 区别在于fold有初始值

```scala
def fold[A1 >: A](z: A1)(op: (A1, A1) ⇒ A1): A1              
```

- 第一个参数列表表示初始值

- 第二个参数列表表示函数的定义

# **Scala成员访问修饰符**

- `private`修饰的成员只允许本类访问（ java中, 外层类成员可以访问内部类的私有成员）

- `protected`修饰的成员只能该类自身与子类可以访问

# **Scala构造器**

## **主构造器**

在构造类的时候{}中的语句都被执行

## **辅助构造器**

不改变主构造器，添加新的参数

辅助构造器的第一行要调用主构造器或其他辅助构造器

## **单例对象**

**scala中没有静态成员**，使用单例对象——object实现类似于Java中的static，定义在内的所有内容都是静态的

## **伴生对象**

- object与class同名且在同一个scala源文件内
- object内定义静态内容，class中定义非静态内容，合在一起相当于一个带有静态与非静态成员的Java类
- 互为伴生关系可以互相访问私有成员

如有特殊需求，通过`[this]`可以解除该成员的伴生关系

```scala
private[this] var 变量名              
```

## **apply方法**

- object对象后面带括号调用时，会自动寻找apply方法执行。
- apply方法可以重载

### **伴生对象中的apply**

一般使用伴生对象中的apply方法来构建伴生对象

# **继承**

scala中class与object都可以使用extends继承父类

# **覆盖**

子类中使用override对父类的成员进行覆盖

# **类型判断**

## **isInstanceOf类型判断**

受到继承关系影响

## **asInstanceOf类型转换**

## **getClassOf类型判断**

不受继承关系影响

# **抽象类**

abstract修饰的类

类中只要有：

- 抽象方法：没有方法体
- 抽象字段：没有初始化的变量

就是抽象类

# **匿名内部类**

没有名称的子类，直接用来创建实例对象

# **Scala特质：trait**

- trait可以附加多个，但类只能单继承
- trait可以附加给单个对象 使用with
- trait中可以有抽象方法、字段 也可以有具体的方法实现

**trait可以当做接口使用**

**trait中也可以定义具体方法**

**trait中可以同时定义抽象与具体字段**

## **调用链**

类继承了多个trait后，可以依次调用多个trait中的同一个方法，只要让多个trait中的同一个方法在最后都依次执行super关键字即可。类中调用多个tait中都有这个方法时，首先会从最右边的trait方法开始执行，然后依次往左执行，形成一个调用链条。

- 先同层，从右到左调用
- 后自己

## **trait的构造机制**

- 优先构造父（class、trait）
- 如果有多个父，按从左到右的顺序构造

# **样例类**

## **定义**

```scala
case class 样例类名([var/val] 参数列表)              
```

参数列表中默认类型为val，如需可变参数需要手动指定var

## **样例类中的方法**

case自动实现了以下方法，可直接调用：

- toString
- apply
- equals：使用 == 自动调用equals
- hashCode：值相同的对象，hashCode值相同
- copy：可以快速创建一个相同的实例对象，可以使用带名参数给指定成员进行重新赋值
- unapply

# **模式匹配**

## **简单模式匹配**

```scala
变量 match {
	case "常量1" => 表达式1
    case "常量2" => 表达式2
    case "常量3" => 表达式3
    case _ => 表达式4		// 默认匹配
}              
```

case _  表示匹配任何

## **匹配类型**

```scala
变量 match {
	case 类型1变量名: 类型1 => 表达式1
    case 类型2变量名: 类型2 => 表达式2
    case 类型3变量名: 类型3 => 表达式3
    ...
    case _ => 表达式4
} 
```

## **模式匹配的守卫**

在case语句中添加if条件判断，要求同时满足匹配条件与if条件才进入后续表达式

## **匹配样例类**

样例类匹配成功后会将对象的参数赋值给匹配的类型的参数列表

## **匹配数组**

```scala
arr match {
	case Array(1,x,y)   // 以1开头，后续的两个元素不固定
    case Array(0)	   // 只匹配一个0元素的元素
    case Array(0, ...)  // 可以任意数量，但是以0开头
}  
```

用变量站位接收后可继续使用功能

## **匹配列表**

```scala
list match {
	List(0)				// 只保存0一个元素的列表
    List(0,...)   		// 以0开头的列表，数量不固定
    List(0,_*)   		// 以0开头的列表，数量不固定
    List(x,y)、
}

list match {
	case 0 :: Nil => println("只有0的列表")
    case 0 :: tail => println("0开头的列表")
    case x :: y :: Nil => println(s"只有另两个元素${x}, ${y}的列表")
    case _ => println("未匹配")
}  
```

## **匹配元组**

```scala
(1, x, y)		// 以1开头的、一共三个元素的元组
(x, y, 5)   // 一共有三个元素，最后一个元素为5的元组              
```

## **变量声明中模式匹配**

```scala
val array = (1 to 10).toArray
val Array(_, x, y, z, _*) = array  //array中第二个元素赋值给x，第三个元素赋值给y，第四个元素赋值给z
val list = (1 to 10).toList val x :: y :: tail = list
```

# **Option类型**

返回某些数据时，可以返回一个Option类型来替代

Option类型的两个子类：

- Some(x)：表示实际的值
- None：表示没有值

用getOrElse方法，当值为None是可以指定一个默认值

# **偏函数**

一组没有match的case语句

偏函数是PartialFunction[A, B]的一个实例

- A代表输入参数类型(只有一个输入参数)
- B代表返回结果类型

# **正则表达式**

```scala
//定义正则表达式
val regEx: Regex = """正则表达式""".r              
```

## **匹配单个字符**

```scala
//使用findAllMatchIn方法可以获取到所有正则匹配到的字符串
if(regEx.findAllMatchIn(字符串).size > 0)
```

## **匹配集合**

使用集合的filter方法配合findAllMatchIn，把符合条件的字段留下来

**匹配分组**

使用括号来匹配分组

`x @ regex(y)` 表明x 这个字符串 能够匹配 带有分组(y)的这个正则

# **异常处理**

## **捕获异常**

```scala
try {
	// 代码
} catch {
	case ex:异常类型1 => // 代码
    case ex:异常类型2 => // 代码
} finally {
	// 代码
}  
```

scala中的catch是一个偏函数，可以匹配多种类型的异常

## **抛出异常**

使用`throw`抛出异常

不需要声明

# **提取器**

## **定义**

```scala
def unapply(stu:Student):Option[(类型1, 类型2, 类型3...)] = {
	if(stu != null) {
    	Some((变量1, 变量2, 变量3...))
    } else {
    	None
    }
}         
```

# **泛型**

## **定义泛型**

```scala
def 方法名[泛型名称](传入参数列表) = {
	方法体
}              
```

## **定义泛型类**

```scala
class 类[T](val 变量名: T)              
```

## **泛型上下界**

```scala
[T <: 上界类型]              
```

参数类型只能上上界本身或上界的子类

```scala
[T >: 下界类型]              
```

参数类型只能下界本身或下界的父类                                     

# **非变、协变、逆变**

- 非变：class[T]，在使用泛型类型的时候不保留外部的继承关系
- 协变：class[+T]，在使用泛型类型的时候保留外部的继承关系
- 逆变：class[-T]，在使用泛型类型的时候反转了继承关系

# **Actor**

Actor不共享数据，直接通过消息传递的机制进行进程间的通讯 没有锁

## **Actor创建**

## **Actor发送消息**

`!` 表示异步发送 不要返回值

`!?` 表示同步发送 等待返回值

`!!` 表示异步发送 接收返回值（返回值是当即得到的一个Futura)

## **Actor接收消息**

Actor中使用receive方法来接收消息，需要给receive方法传入一个偏函数

# **高阶函数**

## **柯里化**

柯里化（Currying）是指将原先接受多个参数的方法转换为多个只有一个参数的参数列表的过程。

![image-20230607164359944](http://image.coolcode.fun/images/202306071645749.png)

- 方法：处理的逻辑写好了，被处理的参数还没传入

- 柯里化：被处理的参数给定了，但是如何处理还不知道

通过柯里化的概念，可以得到一个处理参数确定，处理逻辑等待传入的函数

## **闭包**

函数的返回值依赖于声明在函数外部（甚至可以定义在配置文件中）的变量。

外部变量发生改变也会改变函数的返回值

这种外部变化引起内部变化的就叫做闭包

## **隐式转换与隐式参数**

### **隐式转换**

scala自动将一个对象转换成另一个方法对象，从而可以调用它原本不具有的方法。

### **隐式参数**

使用`implicit`定义一个与所需参数**格式相同**的隐式参数，方法调用时会自动传入定义好的隐式参数

